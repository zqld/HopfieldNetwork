import java.util.Arrays; // Импортируем класс Arrays для работы с массивами

public class HopfieldNetwork {
    private final int size; // размер сети (количество нейронов)
    private final double[][] weights; // весовая матрица

    // Конструктор, инициализирует сеть из size нейронов
    public HopfieldNetwork(int size) {
        this.size = size; // Устанавливаем размер сети
        this.weights = new double[size][size]; // Инициализируем весовую матрицу нулями
    }

    // Обучение сети на основе множества образов
    public void train(int[][] patterns) {
        for (int[] pattern : patterns) { // Проходим по каждому паттерну
            // Обучение по правилу Хебба
            for (int i = 0; i < size; i++) { // Для каждого нейрона
                for (int j = 0; j < size; j++) { // Для каждого нейрона
                    if (i != j) { // Игнорируем самосвязи
                        weights[i][j] += pattern[i] * pattern[j]; // Обновляем вес
                    }
                }
            }
        }
    }

    // Асинхронное обновление состояния сети
    public int[] run(int[] initialPattern, int maxIterations) {
        int[] currentState = Arrays.copyOf(initialPattern, initialPattern.length); // Копируем начальное состояние

        for (int iter = 0; iter < maxIterations; iter++) { // Процесс итерации
            int[] newState = Arrays.copyOf(currentState, currentState.length); // Копируем текущее состояние для обновления

            for (int i = 0; i < size; i++) { // Для каждого нейрона
                double sum = 0; // Инициализируем сумму
                for (int j = 0; j < size; j++) { // Проходим по всем нейронам
                    sum += weights[i][j] * currentState[j]; // Считаем взвешенную сумму
                }
                newState[i] = sum >= 0 ? 1 : -1; // Применяем активационную функцию: если сумма >= 0, нейрон активен, иначе - нет
            }

            if (Arrays.equals(newState, currentState)) { // Если новое состояние не изменилось
                break; // сеть стабилизировалась
            }

            currentState = newState; // Обновляем текущее состояние
        }

        return currentState; // Возвращаем восстановленное состояние
    }

    // Метод для преобразования 10x10 изображения в одномерный массив
    public static int[] flatten(int[][] pattern) {
        int[] flat = new int[pattern.length * pattern[0].length]; // Создаем одномерный массив для хранения значений
        int index = 0; // Индекс для заполнения массива
        for (int[] row : pattern) { // Для каждой строки в паттерне
            for (int value : row) { // Для каждого значения в строке
                flat[index++] = value; // Заполняем одномерный массив
            }
        }
        return flat; // Возвращаем одномерный массив
    }

    // Метод для восстановления двумерного массива из одномерного
    public static int[][] reshape(int[] flat, int rows, int cols) {
        int[][] reshaped = new int[rows][cols]; // Создаем двумерный массив
        for (int i = 0; i < flat.length; i++) { // Проходим по всем элементам одномерного массива
            reshaped[i / cols][i % cols] = flat[i]; // Заполняем двумерный массив по индексам
        }
        return reshaped; // Возвращаем восстановленный двумерный массив
    }

    // Вывод массива 10x10 на экран
    public static void printPattern(int[][] pattern) {
        for (int[] row : pattern) { // Для каждой строки в паттерне
            for (int val : row) { // Для каждого значения в строке
                System.out.print(val == 1 ? "#" : "."); // Выводим "#" для 1 и "." для -1
            }
            System.out.println(); // Переход на новую строку
        }
    }

    // Основной метод для тестирования
    public static void main(String[] args) {
        // Определяем шаблоны цифр
        int[][][] digits = {
                { // Паттерн для цифры 0
                        { -1, -1, 1, 1, 1, 1, 1, 1, -1, -1 },
                        { -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 },
                        { -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 },
                        { -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 },
                        { -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 },
                        { -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 },
                        { -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 },
                        { -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 },
                        { -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 },
                        { -1, -1, 1, 1, 1, 1, 1, 1, -1, -1 }
                },

                { // Паттерн для цифры 2
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, -1 },
                        { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                        { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                        { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, -1 },
                        { 1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
                        { 1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
                        { 1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
                        { 1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, -1 }
                },

                { // Паттерн для цифры 3
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, -1 },
                        { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                        { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                        { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, -1 },
                        { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                        { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                        { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, -1 },
                        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }
                },

        };

        // Сохраняем в массив шаблонов
        int[][] patterns = Arrays.stream(digits) // Преобразуем массив изображений в одномерные массивы
                .map(HopfieldNetwork::flatten)
                .toArray(int[][]::new); // Получаем массив паттернов

        HopfieldNetwork network = new HopfieldNetwork(100); // Создаем сеть с 100 нейронами
        network.train(patterns); // Обучаем сеть на заданных паттернах

        // Шумный вход
        int[][] noisyDigit = { // Шумное изображение, которое будет использовано для восстановления
                { 1, 1, 1, 1, 1, 1, 1, 1, 1, -1 },
                { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                { -1, -1, -1, -1, -1, -1, -1, -1, 1, -1 },
                { 1, 1, 1, 1, 1, 1, 1, 1, 1, -1 },
                { 1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
                { 1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
                { 1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
                { 1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
                { 1, 1, 1, 1, 1, 1, 1, 1, 1, -1 }
        };

        int[] flatNoisyDigit = flatten(noisyDigit); // Преобразуем шумное изображение в одномерный массив
        int[] result = network.run(flatNoisyDigit, 100); // Запускаем сеть для восстановления изображения
        int[][] restoredPattern = reshape(result, 10, 10); // Преобразуем результат обратно в двумерный массив

        System.out.println("Восстановленное изображение:"); // Выводим сообщение
        printPattern(restoredPattern); // Выводим восстановленное изображение
    }
}
